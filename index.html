<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
<title>Ant Game</title>
<style>
  html, body {
    margin: 0;
    height: 100%;
    background: #000;
    color: #fff;
    font-family: Arial, sans-serif;
    overflow: hidden;
    touch-action: none; /* —á—Ç–æ–±—ã –∂–µ—Å—Ç—ã –∑—É–º–∞ –∏ —Å–∫—Ä–æ–ª–ª–∞ –Ω–µ –º–µ—à–∞–ª–∏ */
  }
  .wrap {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: flex-start;
    height: 100%;
    padding-top: 12px;
  }
  h1 {
    font-size: 26px;
    margin: 8px 0;
    text-align: center;
  }
  canvas {
    background: repeating-linear-gradient(90deg, #1a1a1a 0 48px, #222 48px 96px),
                repeating-linear-gradient(0deg, #1a1a1a 0 48px, #222 48px 96px);
    border: 3px solid #222;
    box-shadow: 0 6px 20px rgba(0, 0, 0, 0.6);
    display: block;
    touch-action: none;
    border-radius: 10px;
  }
  .hint {
    color: #bbb;
    font-size: 14px;
    margin-top: 10px;
    text-align: center;
  }
</style>
</head>
<body>
<div class="wrap">
  <h1>Ant Game üêú</h1>
  <canvas id="game"></canvas>
  <div class="hint">–ö–æ—Å–Ω–∏—Å—å –º—É—Ä–∞–≤—å—è, —á—Ç–æ–±—ã —Ä–∞–∑–¥–∞–≤–∏—Ç—å!</div>
</div>

<script>
(() => {
  const canvas = document.getElementById("game");
  const ctx = canvas.getContext("2d");
  const dpr = window.devicePixelRatio || 1;

  // === –ù–∞—Å—Ç—Ä–æ–π–∫–∏ ===
  const ANT_COUNT = 6;
  const MIN_SIZE = 18;
  const MAX_SIZE = 42;
  const MAX_SPEED = 1.8;
  const BLOOD_LIFE = 400;
  const BLOOD_PARTICLES = 16;

  let score = 0;
  const ants = [];
  const bloods = [];

  // === –†–∞–∑–º–µ—Ä –∏ –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—è ===
  function resizeCanvas() {
    // –î–µ–ª–∞–µ–º –≤–µ—Ä—Ç–∏–∫–∞–ª—å–Ω—É—é –æ—Ä–∏–µ–Ω—Ç–∞—Ü–∏—é (–ø–æ—Ä—Ç—Ä–µ—Ç)
    const portrait = window.innerHeight > window.innerWidth;
    const w = portrait ? window.innerWidth * 0.95 : window.innerHeight * 0.8;
    const h = portrait ? window.innerHeight * 0.7 : window.innerHeight * 0.7;

    canvas.width = w * dpr;
    canvas.height = h * dpr;
    canvas.style.width = `${w}px`;
    canvas.style.height = `${h}px`;

    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
  }

  // === –ú—É—Ä–∞–≤–µ–π ===
  function makeAnt() {
    const size = MIN_SIZE + Math.random() * (MAX_SIZE - MIN_SIZE);
    return {
      x: Math.random() * canvas.width / dpr,
      y: Math.random() * canvas.height / dpr,
      dx: (Math.random() - 0.5) * 2,
      dy: (Math.random() - 0.5) * 2,
      size,
      angle: 0,
      alive: true,
      wanderTimer: Math.random() * 120 + 40
    };
  }

  for (let i = 0; i < ANT_COUNT; i++) ants.push(makeAnt());

  function drawAntShape(ctx, size) {
    ctx.fillStyle = "#0c0c0c";
    ctx.strokeStyle = "#050505";
    ctx.lineWidth = Math.max(1, size * 0.06);

    // –ë—Ä—é—à–∫–æ
    ctx.beginPath();
    ctx.ellipse(0, size * 0.15, size * 0.42, size * 0.28, 0, 0, Math.PI * 2);
    ctx.fill(); ctx.stroke();

    // –ì—Ä—É–¥—å
    ctx.beginPath();
    ctx.ellipse(-size * 0.14, 0, size * 0.28, size * 0.2, 0, 0, Math.PI * 2);
    ctx.fill(); ctx.stroke();

    // –ì–æ–ª–æ–≤–∞
    ctx.beginPath();
    ctx.ellipse(-size * 0.4, -size * 0.18, size * 0.18, size * 0.14, 0, 0, Math.PI * 2);
    ctx.fill(); ctx.stroke();

    // –ù–æ–≥–∏
    ctx.strokeStyle = "#070707";
    ctx.lineWidth = Math.max(1, size * 0.06);
    for (let side = -1; side <= 1; side += 2) {
      ctx.beginPath();
      ctx.moveTo(-size * 0.05, -size * 0.08);
      ctx.lineTo(size * 0.35 * side, -size * 0.5);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-size * 0.08, 0);
      ctx.lineTo(size * 0.4 * side, 0);
      ctx.stroke();

      ctx.beginPath();
      ctx.moveTo(-size * 0.02, size * 0.12);
      ctx.lineTo(size * 0.35 * side, size * 0.5);
      ctx.stroke();
    }

    // –£—Å–∏–∫–∏
    ctx.strokeStyle = "#0a0a0a";
    ctx.lineWidth = Math.max(1, size * 0.05);
    ctx.beginPath();
    ctx.moveTo(-size * 0.45, -size * 0.28);
    ctx.quadraticCurveTo(-size * 0.9, -size * 0.7, -size * 1.2, -size * 0.6);
    ctx.stroke();
    ctx.beginPath();
    ctx.moveTo(-size * 0.35, -size * 0.26);
    ctx.quadraticCurveTo(-size * 0.7, -size * 0.6, -size * 1.05, -size * 0.4);
    ctx.stroke();
  }

  function spawnBlood(x, y, baseSize) {
    const particles = [];
    for (let i = 0; i < BLOOD_PARTICLES; i++) {
      const ang = Math.random() * Math.PI * 2;
      particles.push({
        x: x + Math.cos(ang) * (Math.random() * baseSize * 0.5),
        y: y + Math.sin(ang) * (Math.random() * baseSize * 0.5),
        r: Math.random() * (baseSize * 0.12) + (baseSize * 0.04),
        life: 0,
        vx: Math.cos(ang) * (Math.random() * 0.5),
        vy: Math.sin(ang) * (Math.random() * 0.5)
      });
    }
    bloods.push({ particles, life: 0, opacity: 1 });
  }

  function handlePointer(x, y) {
    let hit = false;
    const sorted = ants.slice().sort((a,b)=> Math.hypot(a.x-x,a.y-y)-Math.hypot(b.x-x,b.y-y));
    for (const a of sorted) {
      if (!a.alive) continue;
      const dist = Math.hypot(a.x - x, a.y - y);
      const radius = a.size * 0.6;
      if (dist < radius) {
        a.alive = false;
        hit = true;
        score++;
        spawnBlood(a.x, a.y, a.size);
        setTimeout(() => Object.assign(a, makeAntRespawn()), 1000 + Math.random() * 1800);
        break;
      }
    }
    return hit;
  }

  // === –û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–∞—Å–∞–Ω–∏–π –∏ –∫–ª–∏–∫–æ–≤ ===
  const processTouch = e => {
    const r = canvas.getBoundingClientRect();
    for (let t of e.changedTouches) {
      handlePointer((t.clientX - r.left), (t.clientY - r.top));
    }
    e.preventDefault();
  };

  canvas.addEventListener("touchstart", processTouch, { passive: false });
  canvas.addEventListener("click", e => {
    const r = canvas.getBoundingClientRect();
    handlePointer(e.clientX - r.left, e.clientY - r.top);
  });

  function makeAntRespawn() {
    const size = MIN_SIZE + Math.random() * (MAX_SIZE - MIN_SIZE);
    const w = canvas.width / dpr, h = canvas.height / dpr;
    const edge = Math.floor(Math.random()*4);
    let x, y, dx, dy;
    const speed = 0.6 + Math.random()*1.2;
    switch(edge) {
      case 0: x = -size; y = Math.random()*h; dx = speed; dy = (Math.random()-0.5)*1.2; break;
      case 1: x = w + size; y = Math.random()*h; dx = -speed; dy = (Math.random()-0.5)*1.2; break;
      case 2: x = Math.random()*w; y = -size; dx = (Math.random()-0.5)*1.2; dy = speed; break;
      default: x = Math.random()*w; y = h + size; dx = (Math.random()-0.5)*1.2; dy = -speed; break;
    }
    return { x, y, dx, dy, size, angle: 0, alive: true, wanderTimer: Math.random()*120+40 };
  }

  function maybeRemoveIfFar(a) {
    const margin = a.size * 2 + 60;
    const w = canvas.width / dpr, h = canvas.height / dpr;
    if (a.x < -margin || a.x > w + margin || a.y < -margin || a.y > h + margin) {
      a.alive = false;
      setTimeout(() => Object.assign(a, makeAntRespawn()), 600);
    }
  }

  function update() {
    const w = canvas.width / dpr, h = canvas.height / dpr;
    ctx.clearRect(0, 0, w, h);

    for (let i = bloods.length-1; i >= 0; i--) {
      const blood = bloods[i];
      blood.life++;
      blood.opacity = Math.max(0, 1 - blood.life / BLOOD_LIFE);
      for (const p of blood.particles) {
        const px = p.x + p.vx * Math.min(p.life, 10);
        const py = p.y + p.vy * Math.min(p.life, 10);
        ctx.beginPath();
        ctx.fillStyle = `rgba(130,10,10,${blood.opacity})`;
        ctx.ellipse(px, py, p.r, p.r*0.7, 0, 0, Math.PI*2);
        ctx.fill();
        p.life++;
      }
      if (blood.life > BLOOD_LIFE + 120) bloods.splice(i,1);
    }

    for (const a of ants) {
      if (!a.alive) continue;
      a.x += a.dx;
      a.y += a.dy;
      a.wanderTimer--;
      if (a.wanderTimer <= 0) {
        a.dx += (Math.random()-0.5) * 0.8;
        a.dy += (Math.random()-0.5) * 0.8;
        a.wanderTimer = Math.random() * 120 + 60;
      }
      let sp = Math.hypot(a.dx, a.dy);
      if (sp > MAX_SPEED) {
        a.dx = (a.dx / sp) * MAX_SPEED;
        a.dy = (a.dy / sp) * MAX_SPEED;
      }
      a.dx *= 0.995;
      a.dy *= 0.995;
      a.angle = Math.atan2(a.dy, a.dx);
      maybeRemoveIfFar(a);

      ctx.save();
      ctx.translate(a.x, a.y);
      ctx.rotate(a.angle + Math.PI / 2);
      drawAntShape(ctx, a.size);
      ctx.restore();
    }

    ctx.fillStyle = "#fff";
    ctx.font = "18px monospace";
    ctx.fillText("Score: " + score, 10, 26);

    requestAnimationFrame(update);
  }

  window.addEventListener("resize", resizeCanvas);
  resizeCanvas();
  update();
})();
</script>
</body>
</html>
